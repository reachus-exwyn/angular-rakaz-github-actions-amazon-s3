import { Component, Input, Output, EventEmitter, HostListener, forwardRef, Inject, Optional, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { UI_SWITCH_OPTIONS } from './ui-switch.token';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
const UI_SWITCH_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => UiSwitchComponent),
    multi: true,
};
export class UiSwitchComponent {
    cdr;
    _checked;
    _disabled;
    _reverse;
    _loading;
    _beforeChange;
    size;
    color;
    switchOffColor;
    switchColor;
    defaultBgColor;
    defaultBoColor;
    checkedLabel;
    uncheckedLabel;
    checkedTextColor;
    uncheckedTextColor;
    beforeChange;
    ariaLabel;
    set checked(v) {
        this._checked = v !== false;
    }
    get checked() {
        return this._checked;
    }
    set disabled(v) {
        this._disabled = v !== false;
    }
    get disabled() {
        return this._disabled;
    }
    set reverse(v) {
        this._reverse = v !== false;
    }
    get reverse() {
        return this._reverse;
    }
    set loading(v) {
        this._loading = v !== false;
    }
    get loading() {
        return this._loading;
    }
    /**
     * Emits changed value
     */
    // eslint-disable-next-line @angular-eslint/no-output-native
    change = new EventEmitter();
    /**
     * Emits DOM event
     */
    changeEvent = new EventEmitter();
    /**
     * Emits changed value
     */
    valueChange = new EventEmitter();
    constructor(config = {}, cdr) {
        this.cdr = cdr;
        this.size = (config && config.size) || 'medium';
        this.color = config && config.color;
        this.switchOffColor = config && config.switchOffColor;
        this.switchColor = config && config.switchColor;
        this.defaultBgColor = config && config.defaultBgColor;
        this.defaultBoColor = config && config.defaultBoColor;
        this.checkedLabel = config && config.checkedLabel;
        this.uncheckedLabel = config && config.uncheckedLabel;
        this.checkedTextColor = config && config.checkedTextColor;
        this.uncheckedTextColor = config && config.uncheckedTextColor;
    }
    getColor(flag = '') {
        if (flag === 'borderColor') {
            return this.defaultBoColor;
        }
        if (flag === 'switchColor') {
            if (this.reverse) {
                return !this.checked ? this.switchColor : this.switchOffColor || this.switchColor;
            }
            return this.checked ? this.switchColor : this.switchOffColor || this.switchColor;
        }
        if (flag === 'checkedTextColor') {
            return this.reverse ? this.uncheckedTextColor : this.checkedTextColor;
        }
        if (flag === 'uncheckedTextColor') {
            return this.reverse ? this.checkedTextColor : this.uncheckedTextColor;
        }
        if (this.reverse) {
            return !this.checked ? this.color : this.defaultBgColor;
        }
        return this.checked ? this.color : this.defaultBgColor;
    }
    getLabelClass(labelType) {
        const checked = labelType === (this.reverse ? 'unchecked' : 'checked');
        return checked ? 'switch-label-checked' : 'switch-label-unchecked';
    }
    onClick(event) {
        if (this.disabled) {
            return;
        }
        this.checked = !this.checked;
        // Component events
        this.change.emit(this.checked);
        this.valueChange.emit(this.checked);
        this.changeEvent.emit(event);
        // value accessor callbacks
        this.onChangeCallback(this.checked);
        this.onTouchedCallback(this.checked);
        this.cdr.markForCheck();
    }
    onToggle(event) {
        if (this.disabled) {
            return;
        }
        if (this.beforeChange) {
            this._beforeChange = this.beforeChange.subscribe((confirm) => {
                if (confirm) {
                    this.onClick(event);
                }
            });
        }
        else {
            this.onClick(event);
        }
    }
    writeValue(obj) {
        if (obj !== this.checked) {
            this.checked = !!obj;
        }
        // Added as part of #243 when change detection OnPush is set for the
        // hosting component
        // https://github.com/webcat12345/ngx-ui-switch/issues/243
        if (this.cdr) {
            this.cdr.markForCheck();
        }
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    onTouchedCallback = (v) => { };
    onChangeCallback = (v) => { };
    ngOnDestroy() {
        if (this._beforeChange) {
            this._beforeChange.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UiSwitchComponent, deps: [{ token: UI_SWITCH_OPTIONS, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: UiSwitchComponent, selector: "ui-switch", inputs: { size: "size", color: "color", switchOffColor: "switchOffColor", switchColor: "switchColor", defaultBgColor: "defaultBgColor", defaultBoColor: "defaultBoColor", checkedLabel: "checkedLabel", uncheckedLabel: "uncheckedLabel", checkedTextColor: "checkedTextColor", uncheckedTextColor: "uncheckedTextColor", beforeChange: "beforeChange", ariaLabel: "ariaLabel", checked: "checked", disabled: "disabled", reverse: "reverse", loading: "loading" }, outputs: { change: "change", changeEvent: "changeEvent", valueChange: "valueChange" }, host: { listeners: { "click": "onToggle($event)" } }, providers: [UI_SWITCH_CONTROL_VALUE_ACCESSOR], ngImport: i0, template: "<button\n  type=\"button\"\n  class=\"switch\"\n  role=\"switch\"\n  [attr.aria-checked]=\"reverse ? !checked : checked\"\n  [attr.aria-label]=\"ariaLabel\"\n  [class.checked]=\"reverse ? !checked : checked\"\n  [class.disabled]=\"disabled\"\n  [class.loading]=\"loading\"\n  [class.switch-large]=\"size === 'large'\"\n  [class.switch-medium]=\"size === 'medium'\"\n  [class.switch-small]=\"size === 'small'\"\n  [style.background-color]=\"getColor()\"\n  [style.border-color]=\"getColor('borderColor')\"\n>\n  <label class=\"switch-pane\" *ngIf=\"checkedLabel || uncheckedLabel\">\n    <span\n      [attr.aria-label]=\"this.checkedLabel\"\n      [class]=\"getLabelClass('checked')\"\n      [style.color]=\"getColor('checkedTextColor')\"\n      >{{ this.checkedLabel }}</span\n    >\n    <span\n      [attr.aria-label]=\"this.uncheckedLabel\"\n      [class]=\"getLabelClass('unchecked')\"\n      [style.color]=\"getColor('uncheckedTextColor')\"\n      >{{ this.uncheckedLabel }}</span\n    >\n  </label>\n  <small [style.background]=\"getColor('switchColor')\">\n    <ng-content></ng-content>\n  </small>\n</button>\n", dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UiSwitchComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ui-switch', providers: [UI_SWITCH_CONTROL_VALUE_ACCESSOR], template: "<button\n  type=\"button\"\n  class=\"switch\"\n  role=\"switch\"\n  [attr.aria-checked]=\"reverse ? !checked : checked\"\n  [attr.aria-label]=\"ariaLabel\"\n  [class.checked]=\"reverse ? !checked : checked\"\n  [class.disabled]=\"disabled\"\n  [class.loading]=\"loading\"\n  [class.switch-large]=\"size === 'large'\"\n  [class.switch-medium]=\"size === 'medium'\"\n  [class.switch-small]=\"size === 'small'\"\n  [style.background-color]=\"getColor()\"\n  [style.border-color]=\"getColor('borderColor')\"\n>\n  <label class=\"switch-pane\" *ngIf=\"checkedLabel || uncheckedLabel\">\n    <span\n      [attr.aria-label]=\"this.checkedLabel\"\n      [class]=\"getLabelClass('checked')\"\n      [style.color]=\"getColor('checkedTextColor')\"\n      >{{ this.checkedLabel }}</span\n    >\n    <span\n      [attr.aria-label]=\"this.uncheckedLabel\"\n      [class]=\"getLabelClass('unchecked')\"\n      [style.color]=\"getColor('uncheckedTextColor')\"\n      >{{ this.uncheckedLabel }}</span\n    >\n  </label>\n  <small [style.background]=\"getColor('switchColor')\">\n    <ng-content></ng-content>\n  </small>\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [UI_SWITCH_OPTIONS]
                }, {
                    type: Optional
                }] }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { size: [{
                type: Input
            }], color: [{
                type: Input
            }], switchOffColor: [{
                type: Input
            }], switchColor: [{
                type: Input
            }], defaultBgColor: [{
                type: Input
            }], defaultBoColor: [{
                type: Input
            }], checkedLabel: [{
                type: Input
            }], uncheckedLabel: [{
                type: Input
            }], checkedTextColor: [{
                type: Input
            }], uncheckedTextColor: [{
                type: Input
            }], beforeChange: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], checked: [{
                type: Input
            }], disabled: [{
                type: Input
            }], reverse: [{
                type: Input
            }], loading: [{
                type: Input
            }], change: [{
                type: Output
            }], changeEvent: [{
                type: Output
            }], valueChange: [{
                type: Output
            }], onToggle: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWktc3dpdGNoLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdWktc3dpdGNoL3VpLXN3aXRjaC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi9zcmMvbGliL3VpLXN3aXRjaC91aS1zd2l0Y2guY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixZQUFZLEVBQ1osVUFBVSxFQUNWLE1BQU0sRUFDTixRQUFRLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUF3QixNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG1CQUFtQixDQUFDOzs7QUFJdEQsTUFBTSxnQ0FBZ0MsR0FBUTtJQUM1QyxPQUFPLEVBQUUsaUJBQWlCO0lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUM7SUFDaEQsS0FBSyxFQUFFLElBQUk7Q0FDWixDQUFDO0FBUUYsTUFBTSxPQUFPLGlCQUFpQjtJQTBFbEI7SUF6RUYsUUFBUSxDQUFVO0lBQ2xCLFNBQVMsQ0FBVTtJQUNuQixRQUFRLENBQVU7SUFDbEIsUUFBUSxDQUFVO0lBQ2xCLGFBQWEsQ0FBZTtJQUUzQixJQUFJLENBQUM7SUFDTCxLQUFLLENBQUM7SUFDTixjQUFjLENBQUM7SUFDZixXQUFXLENBQUM7SUFDWixjQUFjLENBQUM7SUFDZixjQUFjLENBQUM7SUFDZixZQUFZLENBQUM7SUFDYixjQUFjLENBQUM7SUFDZixnQkFBZ0IsQ0FBQztJQUNqQixrQkFBa0IsQ0FBQztJQUNuQixZQUFZLENBQXNCO0lBQ2xDLFNBQVMsQ0FBUztJQUUzQixJQUNJLE9BQU8sQ0FBQyxDQUFVO1FBQ3BCLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxLQUFLLEtBQUss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QyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RMaXN0ZW5lcixcbiAgZm9yd2FyZFJlZixcbiAgSW5qZWN0LFxuICBPcHRpb25hbCxcbiAgT25EZXN0cm95LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SLCBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFVJX1NXSVRDSF9PUFRJT05TIH0gZnJvbSAnLi91aS1zd2l0Y2gudG9rZW4nO1xuaW1wb3J0IHsgVWlTd2l0Y2hNb2R1bGVDb25maWcgfSBmcm9tICcuL3VpLXN3aXRjaC5jb25maWcnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IFVJX1NXSVRDSF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBVaVN3aXRjaENvbXBvbmVudCksXG4gIG11bHRpOiB0cnVlLFxufTtcblxuQENvbXBvbmVudCh7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvY29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAndWktc3dpdGNoJyxcbiAgdGVtcGxhdGVVcmw6ICd1aS1zd2l0Y2guY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtVSV9TV0lUQ0hfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUl0sXG59KVxuZXhwb3J0IGNsYXNzIFVpU3dpdGNoQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgX2NoZWNrZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuO1xuICBwcml2YXRlIF9yZXZlcnNlOiBib29sZWFuO1xuICBwcml2YXRlIF9sb2FkaW5nOiBib29sZWFuO1xuICBwcml2YXRlIF9iZWZvcmVDaGFuZ2U6IFN1YnNjcmlwdGlvbjtcblxuICBASW5wdXQoKSBzaXplO1xuICBASW5wdXQoKSBjb2xvcjtcbiAgQElucHV0KCkgc3dpdGNoT2ZmQ29sb3I7XG4gIEBJbnB1dCgpIHN3aXRjaENvbG9yO1xuICBASW5wdXQoKSBkZWZhdWx0QmdDb2xvcjtcbiAgQElucHV0KCkgZGVmYXVsdEJvQ29sb3I7XG4gIEBJbnB1dCgpIGNoZWNrZWRMYWJlbDtcbiAgQElucHV0KCkgdW5jaGVja2VkTGFiZWw7XG4gIEBJbnB1dCgpIGNoZWNrZWRUZXh0Q29sb3I7XG4gIEBJbnB1dCgpIHVuY2hlY2tlZFRleHRDb2xvcjtcbiAgQElucHV0KCkgYmVmb3JlQ2hhbmdlOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuICBASW5wdXQoKSBhcmlhTGFiZWw6IHN0cmluZztcblxuICBASW5wdXQoKVxuICBzZXQgY2hlY2tlZCh2OiBib29sZWFuKSB7XG4gICAgdGhpcy5fY2hlY2tlZCA9IHYgIT09IGZhbHNlO1xuICB9XG5cbiAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgZGlzYWJsZWQodjogYm9vbGVhbikge1xuICAgIHRoaXMuX2Rpc2FibGVkID0gdiAhPT0gZmFsc2U7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IHJldmVyc2UodjogYm9vbGVhbikge1xuICAgIHRoaXMuX3JldmVyc2UgPSB2ICE9PSBmYWxzZTtcbiAgfVxuXG4gIGdldCByZXZlcnNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlO1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IGxvYWRpbmcodjogYm9vbGVhbikge1xuICAgIHRoaXMuX2xvYWRpbmcgPSB2ICE9PSBmYWxzZTtcbiAgfVxuXG4gIGdldCBsb2FkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGNoYW5nZWQgdmFsdWVcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8tb3V0cHV0LW5hdGl2ZVxuICBAT3V0cHV0KCkgY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBET00gZXZlbnRcbiAgICovXG4gIEBPdXRwdXQoKSBjaGFuZ2VFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcblxuICAvKipcbiAgICogRW1pdHMgY2hhbmdlZCB2YWx1ZVxuICAgKi9cbiAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoVUlfU1dJVENIX09QVElPTlMpIEBPcHRpb25hbCgpIGNvbmZpZzogVWlTd2l0Y2hNb2R1bGVDb25maWcgPSB7fSxcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgKSB7XG4gICAgdGhpcy5zaXplID0gKGNvbmZpZyAmJiBjb25maWcuc2l6ZSkgfHwgJ21lZGl1bSc7XG4gICAgdGhpcy5jb2xvciA9IGNvbmZpZyAmJiBjb25maWcuY29sb3I7XG4gICAgdGhpcy5zd2l0Y2hPZmZDb2xvciA9IGNvbmZpZyAmJiBjb25maWcuc3dpdGNoT2ZmQ29sb3I7XG4gICAgdGhpcy5zd2l0Y2hDb2xvciA9IGNvbmZpZyAmJiBjb25maWcuc3dpdGNoQ29sb3I7XG4gICAgdGhpcy5kZWZhdWx0QmdDb2xvciA9IGNvbmZpZyAmJiBjb25maWcuZGVmYXVsdEJnQ29sb3I7XG4gICAgdGhpcy5kZWZhdWx0Qm9Db2xvciA9IGNvbmZpZyAmJiBjb25maWcuZGVmYXVsdEJvQ29sb3I7XG4gICAgdGhpcy5jaGVja2VkTGFiZWwgPSBjb25maWcgJiYgY29uZmlnLmNoZWNrZWRMYWJlbDtcbiAgICB0aGlzLnVuY2hlY2tlZExhYmVsID0gY29uZmlnICYmIGNvbmZpZy51bmNoZWNrZWRMYWJlbDtcbiAgICB0aGlzLmNoZWNrZWRUZXh0Q29sb3IgPSBjb25maWcgJiYgY29uZmlnLmNoZWNrZWRUZXh0Q29sb3I7XG4gICAgdGhpcy51bmNoZWNrZWRUZXh0Q29sb3IgPSBjb25maWcgJiYgY29uZmlnLnVuY2hlY2tlZFRleHRDb2xvcjtcbiAgfVxuXG4gIGdldENvbG9yKGZsYWcgPSAnJykge1xuICAgIGlmIChmbGFnID09PSAnYm9yZGVyQ29sb3InKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0Qm9Db2xvcjtcbiAgICB9XG4gICAgaWYgKGZsYWcgPT09ICdzd2l0Y2hDb2xvcicpIHtcbiAgICAgIGlmICh0aGlzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNoZWNrZWQgPyB0aGlzLnN3aXRjaENvbG9yIDogdGhpcy5zd2l0Y2hPZmZDb2xvciB8fCB0aGlzLnN3aXRjaENvbG9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlZCA/IHRoaXMuc3dpdGNoQ29sb3IgOiB0aGlzLnN3aXRjaE9mZkNvbG9yIHx8IHRoaXMuc3dpdGNoQ29sb3I7XG4gICAgfVxuICAgIGlmIChmbGFnID09PSAnY2hlY2tlZFRleHRDb2xvcicpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UgPyB0aGlzLnVuY2hlY2tlZFRleHRDb2xvciA6IHRoaXMuY2hlY2tlZFRleHRDb2xvcjtcbiAgICB9XG4gICAgaWYgKGZsYWcgPT09ICd1bmNoZWNrZWRUZXh0Q29sb3InKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlID8gdGhpcy5jaGVja2VkVGV4dENvbG9yIDogdGhpcy51bmNoZWNrZWRUZXh0Q29sb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAhdGhpcy5jaGVja2VkID8gdGhpcy5jb2xvciA6IHRoaXMuZGVmYXVsdEJnQ29sb3I7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoZWNrZWQgPyB0aGlzLmNvbG9yIDogdGhpcy5kZWZhdWx0QmdDb2xvcjtcbiAgfVxuXG4gIGdldExhYmVsQ2xhc3MobGFiZWxUeXBlOiAnY2hlY2tlZCcgfCAndW5jaGVja2VkJyk6IHN0cmluZyB7XG4gICAgY29uc3QgY2hlY2tlZCA9IGxhYmVsVHlwZSA9PT0gKHRoaXMucmV2ZXJzZSA/ICd1bmNoZWNrZWQnIDogJ2NoZWNrZWQnKTtcbiAgICByZXR1cm4gY2hlY2tlZCA/ICdzd2l0Y2gtbGFiZWwtY2hlY2tlZCcgOiAnc3dpdGNoLWxhYmVsLXVuY2hlY2tlZCc7XG4gIH1cblxuICBvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcblxuICAgIC8vIENvbXBvbmVudCBldmVudHNcbiAgICB0aGlzLmNoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZCk7XG4gICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZCk7XG4gICAgdGhpcy5jaGFuZ2VFdmVudC5lbWl0KGV2ZW50KTtcblxuICAgIC8vIHZhbHVlIGFjY2Vzc29yIGNhbGxiYWNrc1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLmNoZWNrZWQpO1xuICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sodGhpcy5jaGVja2VkKTtcbiAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSlcbiAgb25Ub2dnbGUoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5iZWZvcmVDaGFuZ2UpIHtcbiAgICAgIHRoaXMuX2JlZm9yZUNoYW5nZSA9IHRoaXMuYmVmb3JlQ2hhbmdlLnN1YnNjcmliZSgoY29uZmlybTogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoY29uZmlybSkge1xuICAgICAgICAgIHRoaXMub25DbGljayhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAob2JqICE9PSB0aGlzLmNoZWNrZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9ICEhb2JqO1xuICAgIH1cblxuICAgIC8vIEFkZGVkIGFzIHBhcnQgb2YgIzI0MyB3aGVuIGNoYW5nZSBkZXRlY3Rpb24gT25QdXNoIGlzIHNldCBmb3IgdGhlXG4gICAgLy8gaG9zdGluZyBjb21wb25lbnRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2ViY2F0MTIzNDUvbmd4LXVpLXN3aXRjaC9pc3N1ZXMvMjQzXG4gICAgaWYgKHRoaXMuY2RyKSB7XG4gICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcbiAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gIH1cblxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgfVxuXG4gIHByaXZhdGUgb25Ub3VjaGVkQ2FsbGJhY2sgPSAodjogYW55KSA9PiB7fTtcbiAgcHJpdmF0ZSBvbkNoYW5nZUNhbGxiYWNrID0gKHY6IGFueSkgPT4ge307XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2JlZm9yZUNoYW5nZSkge1xuICAgICAgdGhpcy5fYmVmb3JlQ2hhbmdlLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG59XG4iLCI8YnV0dG9uXG4gIHR5cGU9XCJidXR0b25cIlxuICBjbGFzcz1cInN3aXRjaFwiXG4gIHJvbGU9XCJzd2l0Y2hcIlxuICBbYXR0ci5hcmlhLWNoZWNrZWRdPVwicmV2ZXJzZSA/ICFjaGVja2VkIDogY2hlY2tlZFwiXG4gIFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcbiAgW2NsYXNzLmNoZWNrZWRdPVwicmV2ZXJzZSA/ICFjaGVja2VkIDogY2hlY2tlZFwiXG4gIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gIFtjbGFzcy5sb2FkaW5nXT1cImxvYWRpbmdcIlxuICBbY2xhc3Muc3dpdGNoLWxhcmdlXT1cInNpemUgPT09ICdsYXJnZSdcIlxuICBbY2xhc3Muc3dpdGNoLW1lZGl1bV09XCJzaXplID09PSAnbWVkaXVtJ1wiXG4gIFtjbGFzcy5zd2l0Y2gtc21hbGxdPVwic2l6ZSA9PT0gJ3NtYWxsJ1wiXG4gIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cImdldENvbG9yKClcIlxuICBbc3R5bGUuYm9yZGVyLWNvbG9yXT1cImdldENvbG9yKCdib3JkZXJDb2xvcicpXCJcbj5cbiAgPGxhYmVsIGNsYXNzPVwic3dpdGNoLXBhbmVcIiAqbmdJZj1cImNoZWNrZWRMYWJlbCB8fCB1bmNoZWNrZWRMYWJlbFwiPlxuICAgIDxzcGFuXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInRoaXMuY2hlY2tlZExhYmVsXCJcbiAgICAgIFtjbGFzc109XCJnZXRMYWJlbENsYXNzKCdjaGVja2VkJylcIlxuICAgICAgW3N0eWxlLmNvbG9yXT1cImdldENvbG9yKCdjaGVja2VkVGV4dENvbG9yJylcIlxuICAgICAgPnt7IHRoaXMuY2hlY2tlZExhYmVsIH19PC9zcGFuXG4gICAgPlxuICAgIDxzcGFuXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInRoaXMudW5jaGVja2VkTGFiZWxcIlxuICAgICAgW2NsYXNzXT1cImdldExhYmVsQ2xhc3MoJ3VuY2hlY2tlZCcpXCJcbiAgICAgIFtzdHlsZS5jb2xvcl09XCJnZXRDb2xvcigndW5jaGVja2VkVGV4dENvbG9yJylcIlxuICAgICAgPnt7IHRoaXMudW5jaGVja2VkTGFiZWwgfX08L3NwYW5cbiAgICA+XG4gIDwvbGFiZWw+XG4gIDxzbWFsbCBbc3R5bGUuYmFja2dyb3VuZF09XCJnZXRDb2xvcignc3dpdGNoQ29sb3InKVwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgPC9zbWFsbD5cbjwvYnV0dG9uPlxuIl19