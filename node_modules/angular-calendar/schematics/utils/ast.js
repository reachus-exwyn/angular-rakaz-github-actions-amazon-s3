"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addModuleImportToRootModule = addModuleImportToRootModule;
exports.insertAfterImports = insertAfterImports;
exports.insertWildcardImport = insertWildcardImport;
exports.isStandaloneComponent = isStandaloneComponent;
exports.addImportsToComponent = addImportsToComponent;
exports.addProvidersToComponent = addProvidersToComponent;
exports.addImportsToNgModule = addImportsToNgModule;
exports.addProvidersToNgModule = addProvidersToNgModule;
var schematics_1 = require("@angular-devkit/schematics");
var change_1 = require("@schematics/angular/utility/change");
var ast_utils_1 = require("@schematics/angular/utility/ast-utils");
var ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
var ts = require("@schematics/angular/third_party/github.com/Microsoft/TypeScript/lib/typescript");
var file_1 = require("./file");
var project_main_file_1 = require("./project-main-file");
/**
 * Import and add module to the root module.
 * @param host {Tree} The source tree.
 * @param importedModuleName {String} The name of the imported module.
 * @param importedModulePath {String} The location of the imported module.
 * @param project {WorkspaceProject} The workspace project.
 */
function addModuleImportToRootModule(host, importedModuleName, importedModulePath, project) {
    var mainPath = (0, project_main_file_1.getProjectMainFile)(project);
    var appModulePath = (0, ng_ast_utils_1.getAppModulePath)(host, mainPath);
    addModuleImportToModule(host, appModulePath, importedModuleName, importedModulePath);
}
/**
 * Import and add module to specific module path.
 * @param host {Tree} The source tree.
 * @param moduleToImportIn {String} The location of the module to import in.
 * @param importedModuleName {String} The name of the imported module.
 * @param importedModulePath {String} The location of the imported module.
 */
function addModuleImportToModule(host, moduleToImportIn, importedModuleName, importedModulePath) {
    var moduleSource = (0, file_1.getSourceFile)(host, moduleToImportIn);
    if (!moduleSource) {
        throw new schematics_1.SchematicsException("Module not found: ".concat(moduleToImportIn));
    }
    var changes = (0, ast_utils_1.addImportToModule)(moduleSource, moduleToImportIn, importedModuleName, importedModulePath);
    var recorder = host.beginUpdate(moduleToImportIn);
    changes
        .filter(function (change) { return change instanceof change_1.InsertChange; })
        .forEach(function (change) { return recorder.insertLeft(change.pos, change.toAdd); });
    host.commitUpdate(recorder);
}
function insertAfterImports(source, fileToEdit, toInsert) {
    var allImports = (0, ast_utils_1.findNodes)(source, ts.SyntaxKind.ImportDeclaration);
    return (0, ast_utils_1.insertAfterLastOccurrence)(allImports, toInsert, fileToEdit, 0, ts.SyntaxKind.StringLiteral);
}
function insertWildcardImport(source, fileToEdit, symbolName, fileName) {
    return insertAfterImports(source, fileToEdit, ";\nimport * as ".concat(symbolName, " from '").concat(fileName, "'"));
}
/**
 * Check if a component is standalone by examining its @Component decorator
 * @param source TypeScript source file
 * @returns true if standalone: true, false if standalone: false, undefined if not specified
 */
function isStandaloneComponent(source) {
    var nodes = (0, ast_utils_1.findNodes)(source, ts.SyntaxKind.Decorator);
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        if (!ts.isDecorator(node))
            continue;
        var callExpr = node.expression;
        if (!ts.isCallExpression(callExpr))
            continue;
        var identifier = callExpr.expression;
        if (!ts.isIdentifier(identifier) || identifier.text !== 'Component')
            continue;
        var args = callExpr.arguments;
        if (args.length === 0)
            continue;
        var configArg = args[0];
        if (!ts.isObjectLiteralExpression(configArg))
            continue;
        for (var _a = 0, _b = configArg.properties; _a < _b.length; _a++) {
            var prop = _b[_a];
            if (!ts.isPropertyAssignment(prop))
                continue;
            var name_1 = prop.name;
            if (!ts.isIdentifier(name_1) || name_1.text !== 'standalone')
                continue;
            var value = prop.initializer;
            if (ts.isLiteralExpression(value)) {
                return value.text === 'true';
            }
            if (value.kind === ts.SyntaxKind.TrueKeyword) {
                return true;
            }
            if (value.kind === ts.SyntaxKind.FalseKeyword) {
                return false;
            }
        }
    }
    return true; // standalone not specified - defaults to true
}
/**
 * Find the @Component decorator in a source file
 */
function findComponentDecorator(source) {
    var nodes = (0, ast_utils_1.findNodes)(source, ts.SyntaxKind.Decorator);
    for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
        var node = nodes_2[_i];
        if (!ts.isDecorator(node))
            continue;
        var callExpr = node.expression;
        if (!ts.isCallExpression(callExpr))
            continue;
        var identifier = callExpr.expression;
        if (ts.isIdentifier(identifier) && identifier.text === 'Component') {
            return node;
        }
    }
    return undefined;
}
/**
 * Add imports array to a standalone component's @Component decorator
 */
function addImportsToComponent(source, fileToEdit, imports) {
    var componentDecorator = findComponentDecorator(source);
    if (!componentDecorator) {
        throw new schematics_1.SchematicsException('Could not find @Component decorator');
    }
    var callExpr = componentDecorator.expression;
    var configArg = callExpr.arguments[0];
    // Find existing imports property
    var importsProperty;
    for (var _i = 0, _a = configArg.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (ts.isPropertyAssignment(prop) &&
            ts.isIdentifier(prop.name) &&
            prop.name.text === 'imports') {
            importsProperty = prop;
            break;
        }
    }
    var changes = [];
    if (importsProperty) {
        // Add to existing imports array
        var importsArray = importsProperty.initializer;
        var lastElement = importsArray.elements[importsArray.elements.length - 1];
        var insertPos = lastElement
            ? lastElement.getEnd()
            : importsArray.getStart() + 1;
        var separator = importsArray.elements.length > 0 ? ', ' : '';
        changes.push(new change_1.InsertChange(fileToEdit, insertPos, separator + imports.join(', ')));
    }
    else {
        // Add new imports property
        var lastProperty = configArg.properties[configArg.properties.length - 1];
        var insertPos = lastProperty
            ? lastProperty.getEnd()
            : configArg.getStart() + 1;
        var separator = configArg.properties.length > 0 ? ',\n  ' : '\n  ';
        changes.push(new change_1.InsertChange(fileToEdit, insertPos, "".concat(separator, "imports: [").concat(imports.join(', '), "],")));
    }
    return changes;
}
/**
 * Add providers array to a standalone component's @Component decorator
 */
function addProvidersToComponent(source, fileToEdit, providers) {
    var componentDecorator = findComponentDecorator(source);
    if (!componentDecorator) {
        throw new schematics_1.SchematicsException('Could not find @Component decorator');
    }
    var callExpr = componentDecorator.expression;
    var configArg = callExpr.arguments[0];
    // Find existing providers property
    var providersProperty;
    for (var _i = 0, _a = configArg.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (ts.isPropertyAssignment(prop) &&
            ts.isIdentifier(prop.name) &&
            prop.name.text === 'providers') {
            providersProperty = prop;
            break;
        }
    }
    var changes = [];
    if (providersProperty) {
        // Add to existing providers array
        var providersArray = providersProperty.initializer;
        var lastElement = providersArray.elements[providersArray.elements.length - 1];
        var insertPos = lastElement
            ? lastElement.getEnd()
            : providersArray.getStart() + 1;
        var separator = providersArray.elements.length > 0 ? ',\n    ' : '';
        changes.push(new change_1.InsertChange(fileToEdit, insertPos, separator + providers.join(',\n    ')));
    }
    else {
        // Add new providers property
        var lastProperty = configArg.properties[configArg.properties.length - 1];
        var insertPos = lastProperty
            ? lastProperty.getEnd()
            : configArg.getStart() + 1;
        var separator = configArg.properties.length > 0 ? ',\n  ' : '\n  ';
        changes.push(new change_1.InsertChange(fileToEdit, insertPos, "".concat(separator, "providers: [\n    ").concat(providers.join(',\n    '), ",\n  ],")));
    }
    return changes;
}
/**
 * Find the @NgModule decorator in a source file
 */
function findNgModuleDecorator(source) {
    var nodes = (0, ast_utils_1.findNodes)(source, ts.SyntaxKind.Decorator);
    for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {
        var node = nodes_3[_i];
        if (!ts.isDecorator(node))
            continue;
        var callExpr = node.expression;
        if (!ts.isCallExpression(callExpr))
            continue;
        var identifier = callExpr.expression;
        if (ts.isIdentifier(identifier) && identifier.text === 'NgModule') {
            return node;
        }
    }
    return undefined;
}
/**
 * Add imports array to an NgModule's @NgModule decorator
 */
function addImportsToNgModule(source, fileToEdit, imports) {
    var ngModuleDecorator = findNgModuleDecorator(source);
    if (!ngModuleDecorator) {
        throw new schematics_1.SchematicsException('Could not find @NgModule decorator');
    }
    var callExpr = ngModuleDecorator.expression;
    var configArg = callExpr.arguments[0];
    // Find existing imports property
    var importsProperty;
    for (var _i = 0, _a = configArg.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (ts.isPropertyAssignment(prop) &&
            ts.isIdentifier(prop.name) &&
            prop.name.text === 'imports') {
            importsProperty = prop;
            break;
        }
    }
    var changes = [];
    if (importsProperty) {
        // Add to existing imports array
        var importsArray = importsProperty.initializer;
        var lastElement = importsArray.elements[importsArray.elements.length - 1];
        var insertPos = lastElement
            ? lastElement.getEnd()
            : importsArray.getStart() + 1;
        var separator = importsArray.elements.length > 0 ? ', ' : '';
        changes.push(new change_1.InsertChange(fileToEdit, insertPos, separator + imports.join(', ')));
    }
    else {
        // Add new imports property
        var lastProperty = configArg.properties[configArg.properties.length - 1];
        var insertPos = lastProperty
            ? lastProperty.getEnd()
            : configArg.getStart() + 1;
        var separator = configArg.properties.length > 0 ? ',\n  ' : '\n  ';
        changes.push(new change_1.InsertChange(fileToEdit, insertPos, "".concat(separator, "imports: [").concat(imports.join(', '), "],")));
    }
    return changes;
}
/**
 * Add providers array to an NgModule's @NgModule decorator
 */
function addProvidersToNgModule(source, fileToEdit, providers) {
    var ngModuleDecorator = findNgModuleDecorator(source);
    if (!ngModuleDecorator) {
        throw new schematics_1.SchematicsException('Could not find @NgModule decorator');
    }
    var callExpr = ngModuleDecorator.expression;
    var configArg = callExpr.arguments[0];
    // Find existing providers property
    var providersProperty;
    for (var _i = 0, _a = configArg.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (ts.isPropertyAssignment(prop) &&
            ts.isIdentifier(prop.name) &&
            prop.name.text === 'providers') {
            providersProperty = prop;
            break;
        }
    }
    var changes = [];
    if (providersProperty) {
        // Add to existing providers array
        var providersArray = providersProperty.initializer;
        var lastElement = providersArray.elements[providersArray.elements.length - 1];
        var insertPos = lastElement
            ? lastElement.getEnd()
            : providersArray.getStart() + 1;
        var separator = providersArray.elements.length > 0 ? ',\n    ' : '';
        changes.push(new change_1.InsertChange(fileToEdit, insertPos, separator + providers.join(',\n    ')));
    }
    else {
        // Add new providers property
        var lastProperty = configArg.properties[configArg.properties.length - 1];
        var insertPos = lastProperty
            ? lastProperty.getEnd()
            : configArg.getStart() + 1;
        var separator = configArg.properties.length > 0 ? ',\n  ' : '\n  ';
        changes.push(new change_1.InsertChange(fileToEdit, insertPos, "".concat(separator, "providers: [\n    ").concat(providers.join(',\n    '), ",\n  ],")));
    }
    return changes;
}
